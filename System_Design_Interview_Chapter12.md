# 12장 - 채팅 시스템 설계

- 채팅 앱이라고 하면 사람들이 떠올리는 것은 제각각
  - 요구사항을 확실하게 해둘 것

## 1단계 : 문제 이해 및 설계 범위 확정

- 어떤 앱을 설계해야 하는지? (1:1 채팅 or 그룹 채팅 앱)
  - 둘 다 지원
- 모바일 앱 or 웹 앱
  - 둘 다 지원
- 처리해야 하는 트래픽 규모는?
  - DAU 기준으로 5천만
- 그룹 채팅의 경우엔 인원 제한이 있는지?
  - 최대 100명
- 중요 기능으론?
  - 1:1 채팅, 그룹 채팅, 사용자 접속 상태 표시, 텍스트 메시지만 지원
- 메시지 길이에 제한은?
  - 10만 자 이하
- 종단 간 암호화는?
  - 시간이 허락되면 논의해 볼 주제
- 채팅 이력 보관 기간은?
  - 영원히
- 앱에서 제공해야 할 기능
  - 응답 지연이 낮은 일대일 채팅 기능
  - 최대 100명까지 참여할 수 있는 그룹 채팅 기능
  - 사용자의 접속 상태 표시 기능
  - 다양한 단말 지원, 하나의 계정으로 여러 단말에 동시 접속 지원
  - 푸시 알림
  - 5천만 DAU 처리

## 2단계 : 개략적 설계안 제시 및 동의 구하기

- 채팅 시스템의 경우 클라이언트는 모바일 앱 or 웹 애플리케이션
  - 클라이언트끼리 서로 직접 통신 X
  - 각 클라이언트는 채팅 서비스와 통신
- 채팅 서비스가 제공해야 할 기능
  - 클라이언트로부터 메시지 수신
  - 메시지 수신자 결정 및 전달
  - 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관
- 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제
  - 송신 클라이언트가 수신 클라이언트에게 전달할 메시지를 HTTP 프로토콜을 사용해서 보냄
  - keep-alive 헤더를 사용하면 효율적 (클라이언트와 서버 사이의 연결을 끊지 않고 TCP 핸드 셰이크 횟수를 줄임)
  - 서버에서 클라이언트로 임의 시점에 메시지를 보내는 데는 폴링, 롱 폴링, 웹소켓 등의 기술이 제안되었음

### 폴링

- 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법
- 폴링을 자주 할수록 폴링 비용이 올라감
- 답해줄 메시지가 없는 경우엔 서버 자원이 불필요하게 낭비

### 롱 폴링

- 폴링의 비효율적인 점을 보완하기 위한 방법
- 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결 유지
  - 새 메시지를 받을 시 기존 연결을 종료하고 서버에 새로운 요청을 보낸 후 모든 절차 다시 시작
- 약점
  - 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있음 (HTTP 무상태 서버에서 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용한 경우)
  - 서버 입장에선 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없음
  - 여전히 비효율적

### 웹소켓

- 서버가 클라이언트에게 비동기(async) 메시지를 보낼 때 가장 널리 사용하는 기술
- 웹소켓 연결은 클라이언트가 시작하고 항구적이며 양방향인 연결
- 처음 HTTP 연결 후 특정 핸드 셰이크 절차를 걸쳐 웹소켓 연결로 업그레이드
- 연결이 만들어지고 나면 서버는 클라이언트에게 비동기적으로 메시지 전송 가능
- 80이나 443처럼 HTTP, HTTPS 기본 포트 번호를 그대로 쓰기 때문에 방화벽 환경에서도 잘 동작
- 연결이 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 함

### 개략적 설계안

- 회원가입, 로그인, 사용자 프로파일 등의 대부분의 기능은 일반적인 HTTP 상에 구현해도 됨
- 채팅 시스템은 무상태 서비스, 상태 유지(stateful), 제3자 서비스 연동으로 나눠짐
- 무상태 서비스
  - 로그인, 회원가입, 사용자 프로파일 표시등을 처리하는 전통적인 요청/응답 서비스
  - 많은 웹사이트와 앱에서 보편적으로 제공
  - 로드밸런서 뒤에 위치
  - '서비스 탐색' 서비스 : 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려줌
- 상태 유지 서비스
  - 유일하게 상태 유지가 필요한 서비스
  - 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 함
- 제3자 서비스 연동
  - 채팅 앱에서 가장 중요한 제3자 서비스는 푸시 알림
- 규모 확장성
  - 모든 것을 서버 한 대에 담는 설계안은 좋은 점수를 얻을 수 없음 (SPOF 등의 이유)
  - 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할
  - 접속 상태 서버는 사용자의 접속 여부 관리
  - API 서버는 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 전부를 처리
  - 알림 서버는 푸시 알림을 보냄
  - 키-값 저장소에는 채팅 이력을 보관
- 저장소
  - 채팅 시스템이 다루는 데이터는 일반적인 데이터와 채팅 시스템 고유 데이터
  - 일반적인 데이터는 관계형 데이터베이스에 보관 (다중화, 샤딩으로 가용성, 규모 확장성 보증)
  - 채팅 시스템의 고유한 데이터는 채팅 이력들
  - 채팅 이력 데이터의 양은 엄청남
  - 대부분의 사용자는 주로 최근에 주고받은 메시지만 확인
  - 검색 기능, 맨션, 특정 메시지로의 점프도 데이터 계층에서 지원해야 함
  - 1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1
  - 수평적 규모 확장의 용이, 낮은 데이터 접근 지연시간, 롱테일에 대한 처리 등의 장점으로 키-값 저장소 추천

### 데이터 모델

- 1:1 채팅을 위한 메시지 테이블
  - createdAt을 기본 키로 할 시 두 메시지가 동시에 만들어질 수 있기 때문에 기본 키를 따로 만듦
- 그룹 채팅을 위한 메시지 테이블
  - channel_id, message_id의 복합키를 기본 키로 사용
  - channel은 채팅 그룹과 같은 뜻
  - channel_id는 파티션 키로도 사용
- 메시지 ID
  - message_id의 값은 고유해야 함
  - ID 값은 정렬 가능해야 하며 시간 순서와 일치해야 함 (새로운 ID는 이전 ID보다 큰 값)
  - NoSQL은 auto_increment를 제공하지 않으므로 스노플레이크, 지역적 순서 번호 생성기 등을 이용
  - 지역적 순서 번호 생성기는 같은 그룹 안에서만 유일성을 보증하며 전역적 ID 생성기에 비해 구현이 쉬움

## 3단계 : 상세 설계

### 서비스 탐색

- 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것이 주 역할
- 클라이언트의 위치, 서버의 용량 등을 기준 삼음
- 아파치 주키퍼와 같은 오픈 소스로 구현
- 사용자가 로그인 후 로드밸런서를 통해 API 서버로 인증 처리 후 서비스 탐색 기능이 최적의 채팅 서버를 찾아주고 그 서버와 웹소켓 연결을 맺음

### 메시지 흐름

- 1:1 채팅 메시지 처리 흐름
  - 사용자 A가 채팅 서버 1로 메시지 전송
  - 채팅 서버 1은 ID 생성기를 사용해 메시지의 ID 결정
  - 채팅 서버 1은 해당 메시지를 메시지 동기화 큐로 전송
  - 메시지가 키-값 저장소에 보관됨
  - 보내는 사용자가 접속 중인 경우 그 사용자가 접속 중인 채팅 서버로 전송
  - 보내는 사용자가 접속 중이 아닌 경우 메시지를 푸시 알림 서버로 보냄
- 여러 단말 사이의 메시지 동기화
  - 각 단말은 cur_max_message_id라는 변수를 유지하고 단말에서 관측된 최신 메시지의 ID 추적
  - 수신자 ID가 현재 로그인한 사용자 ID와 같고 키-값 저장소에 보관된 메시지 ID가 단말 변수보다 클 시 새 메시지로 간주
- 소규모 그룹 채팅에서의 메시지 흐름
  - 한 사용자가 보낸 메시지가 다른 사용자의 메시지 동기화 큐에 복사
  - 이 큐를 사용자 각각에 할당된 메시지 수신함이라고 생각해도 무방
  - 동기화 큐는 소규모 그룹 채팅에 적합 (큐에 넣는 작업의 비용 등의 이유)
  - 한 수신자는 여러 사용자로부터 오는 메시지를 수신할 수 있어야 함

### 접속 상태 표시

- 상당수 채팅 애플리케이션의 핵심적 기능
- 접속 상태 서버(presense server)를 통해 사용자의 상태를 관리
- 접속 상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부
- 사용자 로그인
  - 클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속 상태 서버는 A의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관
  - 이 절차가 끝나고 나면 해당 사용자는 접속 중인 것으로 표시
- 로그아웃
  - 키-값 저장소에 보관된 사용자 상태가 online에서 offline으로 바뀜
  - 이 절차가 끝나면 UI 상에서 사용자의 상태는 접속 중이 아닌 것으로 표시
- 접속 장애
  - 사용자의 인터넷 연결이 끊어지면 웹소켓 같은 지속성 연결도 끊어짐
  - 짧은 시간 동안 인터넷 연결이 끊겼다 복구될 때 사용자의 접속 상태를 변경하는 것은 바람직하지 않음
  - 박동 검사를 이용해 마지막 이벤트를 받은 지 x 초 이내에 또 다른 박동 박동 이벤트 메시지를 받는지 유무로 확인
- 상태 정보의 전송
  - 상태 정보 서버는 발행-구독 모델을 사용해 각각의 친구관계마다 채널을 하나씩 둠
  - 클라이언트와 서버 사이의 통신에는 실시간 웹소켓을 사용
  - 이 방법은 그룹 크기가 작을 때 사용 (그룹이 커지면 건당 발생하는 이벤트 메시지가 너무 많아짐)
  - 성능 문제 해소를 위해 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나 친구 리스트에 있는 사용자의 접속 상태를 수동으로 갱신하도록 유도

## 4단계 : 마무리

- 면접관과 추가로 논의해도 좋은 것
  - 채팅 앱을 확장하여 미디어를 지원하는 방법 (압축 방식, 클라우드 저장소, 섬네일 생성)
  - 종단 간 암호화 (발신인, 수신자 외에는 아무도 메시지 내용을 볼 수 없음)
  - 캐시 (클라이언트에 이미 읽은 메시지를 캐시)
  - 로딩 속도 개선 (사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크 구축)
  - 오류 처리 (서버가 죽는 경우 등의 채팅 서버 오류, 재시도, 큐로 메시지 재전송)
