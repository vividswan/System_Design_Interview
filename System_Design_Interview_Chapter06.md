# 6장 - 키-값 저장소 설계

- 키-값 저장소, 키-값 데이터베이스라고 불리는 비 관계형(non-relational) 데이터베이스
  - 이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 함 (키-값 쌍)
  - 키는 유일해야 하고 짧을수록 좋으며 일반 텍스트이거나 해시 값
  - 키에 매달린 값은 키를 통해서만 접근 가능하며 문자열, 리스트, 객체일 수 있음
- 아마존 다이나모, memcached, 레디스 같은 것들이 유명

## 문제 이해 및 설계 범위 확정

- 이번 장에서 설계해 볼 키-값 저장소의 특성
  - 키-값 쌍의 크기는 10KB 이하
  - 큰 데이터를 저장할 수 있어야 함
  - 높은 가용성 제공 (장애가 있더라도 빨리 응답)
  - 높은 규모 확장성 (트래픽 양에 따라 자동적으로 서버 증설/삭제)
  - 데이터 일관성 수준은 조정이 가능해야 함
  - 응답 지연시간이 짧아야 함

## 단일 서버 키-값 저장소

- 한 대의 서버에서만 키-값 저장소를 설계할 시 다음의 방법으로 개선
  - 데이터 압축
  - 자주 쓰는 데이터만 메모리, 나머지는 디스크에 저장
- 이 개선점도 한계가 있기 때문에 분산 키-값 저장소로 만들 필요가 있음

## 분산 키-값 저장소

- 분산 해시 테이블로도 불림
- CAP 정리를 이해하고 있어야 설계 가능
  - Consistency, Availability, Partition Tolerance theorem

### CAP 정리

- 데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리
  - 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 함
  - 가용성 : 분산 시스템에 접속하는 모든 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 함
  - 파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미하며 네트워크에 파티션이 생기더라도 시스템이 계속 동작하여야 하는 것이 파티션 감내
- 키-값 저장소는 앞서 제시한 세 가지 요구사항 가운데 어느 두 가지를 만족하느냐에 따라 다음과 같이 분류
  - CP 시스템 : 일관성과 파티션 감내를 지원, 가용성 희생
  - AP 시스템 : 가용성과 파티션 감내를 지원, 일관성 희생
  - CA 시스템 : 일관성과 가용성을 지원, 파티션 감내는 지원 X, 실세계에서 CA 시스템은 존재 X (파티션 문제를 감내하는 것은 필수)
- 이상적 상태
  - 이상적 상태에서는 네트워크가 파티션 되는 상황은 절대로 일어나지 않을 것
  - 데이터 일관성과 가용성도 만족
- 실세계의 분산 시스템
  - 파티션 문제가 발생 시 일관성과 가용성 사이에서 하나를 선택해야 함
  - 가용성 대신 일관성을 선택한다면 새 서버 사이에 생길 수 있는 데이터 불일치를 없애기 위해 유효한 노드에 쓰기 연산을 중단 시켜야 함 (보통 은행권)
  - 가용성을 선택하면 낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산 지원

### 시스템 컴포넌트

- 데이터 파티션
  - 대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능
  - 데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것이 가장 단순한 해결책
  - 안정 해시를 통해 데이터를 여러 서버에 고르게 분산하고 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있음
  - 안정 해시를 사용하는 것은 규모 확장 자동화와 다양성(가상 노드)의 장점이 있음

### 데이터 다중화

- 높은 가용성과 안정성 확보를 위해 데이터를 N개 서버에 비동기적으로 다중화 해야 함
  - N은 튜닝 가능한 값
  - 어떤 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관
  - 노드를 선택할 때 같은 물리 서버를 중복 선택하지 않도록 해야 함
  - 안정성을 담보하기 위해 데이터의 사본은 다른 센터에 보관 후 센터들을 고속 네트워크로 연결

### 데이터 일관성

- 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 함
  - 정족수 합의 프로토콜로 읽기/쓰기 연산 모두에 일관성 보장 가능
- 정족수 합의 프로토콜의 관계된 정의
  - N = 사본 개수
  - W = 쓰기 연산에 대한 정족수
  - R = 읽기 연산에 대한 정족수
  - 중재자는 클라이언트와 노드 사이에서 프락시 역할을 하며 W=1의 의미는 쓰기 연산이 성공했다고 판단하려면 중재자는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야 한다는 뜻
  - W, R, N의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협접을 찾는 전형적인 과정
  - 요구되는 일관성 수준에 따라 W, R, N의 값을 조정할 것
- 일관성 모델
  - 키-값 저장소를 설계할 때 고려해야 할 또 하나의 중요한 요소
  - 강한 일관성 : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환해야 함 (클라이언트는 절대로 낡은 데이터를 보지 못함)
  - 약한 일관성 : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있음
  - 최종 일관성 : 약한 일관성의 한 형태, 갱신 결과가 결국에는 모든 사본에 반영(동기화) 되는 모델
  - 최종 일관성 모들을 따를 경우 연산이 병렬적으로 발생하면 저장된 값의 일관성이 깨어질 수 있는 데 이 문제는 클라이언트가 해결해야 함
- 비 일관성 해소 기법 : 데이터 버저닝
  - 버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것을 의미, 각 버전의 데이터는 변경 불가능 (immutable)
  - 백터 시계는 [서버, 버전]의 순서쌍을 데이터에 매단 것, 어떤 버전이 선행 버전인지, 후행 버전인지, 다른 버전과 충돌이 있는지 판별할 때 쓰임
  - 백터 시계에서 vi는 버전 카운터, Si는 서버 번호, 기존의 백터 카운터가 없다면 새 항복 [Si, 1]을 만듦, 있다면 vi를 증가
  - 백터 시계를 사용하면 어떤 버전 X가 버전 Y의 이전 버전인지 쉽게 판단 가능
  - 어떤 버전 X와 Y 사이에 충돌이 있는지 보려면 Y의 벡터 시계 구성요소 가운데 백터 시계 동일 서버 구성요소보다 작은 값을 갖는 것이 있는지 보면 됨
  - 충돌 감지 및 해소 로직이 클라이언트에 들어가므로 클라이언트 구현이 복잡해진다는 단점이 있음
  - [서버: 버전]의 순서쌍 개수가 굉장히 빨리 늘어난다는 단점이 있음 -> 임계치를 설정하여 임계치 이상으로 길이가 길어지면 오래된 순서쌍을 백터 시계에서 제거
- 장애 처리
  - 대다수 대규모 시스템에서 장애는 아주 흔하게 벌어지는 사건
  - 장애 감지 기법을 살펴보고 장애 해소 전략들을 짚어봐야 함
- 장애 감지
  - 분산 시스템에선 서버 한 대가 죽었다고 보고를 해도 장애 처리하지 않음
  - 두 대 이상의 서버가 똑같이 장애보고를 해야 실제로 서버에 장애가 발생했다고 간주
  - 모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 서버 장애를 감지하는 가장 쉬운 방법이지만 서버가 많을 때는 비효율적
  - 가십 프로토콜 같은 분산형 장애 감지 솔루션을 채택하는 편이 보다 효율적
  - 가십 프로토콜은 각 노드가 멤버십 목록을 유지하여 박동 카운터를 기록하고 그 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애(offline)인 것으로 판별
- 일시적 장애 처리
  - 장개가 감지되면 가용성을 보장하기 위해 필요한 조치를 해야 함
  - 엄격한 정족수 접근법은 읽기와 쓰기 연산을 금지
  - 느슨한 정족수 접근법은 조건을 완화하여 가용성을 높임
    - 정족수 요구사항을 강제하는 대신, 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건강한 서버를 해시 링에서 고름 (장애 서버는 무시)
  - 장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리 후 힌트를 남겨두어 서버가 복구되었을 때 변경사항을 일관 반영하여 데이터 일관성을 보장 (단서 후 임시 위탁 기법)
- 영구 장애 처리
  - 영구적인 노드의 장애 상태를 처리하기 위해 반-엔트로피(anti-entropy) 프로토콜을 구현하여 사본들을 동기화해야 함
  - 반-엔트로피 프로토콜은 사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함
  - 사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서는 머클 트리를 사용
  - 머클 트리는 각 노드에 그 자식 노드들에 보관된 값의 해시나 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리
  - 해시 트리로 대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증 가능
  - 키 공간을 버킷으로 나눈 뒤 버킷에 포함된 각각의 키에 균등 분포 해시 함수를 적용, 버킷 별로 해시 값을 계산 후 그 값을 레이블로 갖는 노드를 생성 (이진 트리를 상향식으로 구성)
  - 루트에서 아래로 탐색하며 다른 데이터를 갖는 버킷들만 동기화
- 데이터 센터 장애 처리
  - 여러 데이터 센터에 다중화하는 것이 중요

### 시스템 아키텍처 다이어그램

- 시스템 아키텍처의 주된 기능
  - 클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API와 통신
  - 중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드
  - 노드는 안정 해시의 해시 링 위에 분포
  - 노드를 자동으로 추가 또는 삭제할 수 있도록 시스템은 완전히 분산
  - 데이터는 여러 노드에 다중화
  - 모든 노드가 같은 책임을 지므로 SPOF는 존재 X

### 쓰기 경로

- 쓰기 요청이 특정 노드에 전달되면 일어나는 일
  - 쓰기 요청이 커밋 로그 파일에 기록
  - 데이터가 메모리 캐시에 기록
  - 메모리 캐시가 가득 차거나 임계치에 도달하면 데이터는 디스크의 SSTable에 기록
  - SSTable은 Sorted-String Table의 약어 (<키,값>의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블)

### 읽기 경로

- 읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 확인
- 메모리가 없을 시 디스크에서 가져옴
  - 어느 SSTable에 찾는 키가 있는지 알아내기 위해 블룸 필터가 흔히 사용됨

## 요약

- 대규모 데이터 저장 : 안정 해시를 사용해 서버들에 부하 분산
- 읽기 연산에 대한 높은 가용성 보장 : 데이터를 여러 데이터 센터에 다중화
- 쓰기 연산에 대한 높은 가용성 보장 : 버저닝 및 벡터 시계를 사용한 충돌 해소
- 데이터 파티션 : 안정 해시
- 점진적 규모 확장성 : 안정 해시
- 다양성 : 안정 해시
- 조절 가능한 데이터 일관성 : 정족수 협의
- 일시적 장애 처리 : 느슨한 정족수 프로토콜과 단서 후 임시 위탁
- 영구적 장애 처리 : 머클 트리
- 데이터 센터 장애 대응 : 여러 데이터 센터에 걸친 데이터 다중화
