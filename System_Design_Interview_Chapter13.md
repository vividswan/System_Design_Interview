# 13장 - 검색어 자동완성 시스템

- 검색어 자동완성
  - 입력 중인 글자에 맞는 검색어가 자동으로 완성되어 표기

## 1단계 : 문제 이해 및 설계 범위 확정

- 사용자 입력 단어는 자동완성될 검색어의 첫 부분 or 중간 부분?
  - 첫 부분 한정
- 몇 개의 자동완성 검색어를 표시?
  - 5개
- 5개의 자동완성 검색어를 고르는 기준
  - 질의 빈도에 따라 정해지는 검색어 인기 순위
- 맞춤법 검사 기능은?
  - 맞춤법 검사 or 자동 수정은 지원 X
- 질의는 영어?
  - 영어지만 시간이 허락할 시 다국어
- 대문자나 특수 문자 처리?
  - X
  - 모든 질의는 영어 소문자로 이루어진다고 가정
- 얼마나 많은 사용자를 지원?
  - DAU 기준으로 천만

### 요구 사항

- 빠른 응답 속도 : 100밀리초 이내 (이상일 시 이용 불편)
- 연관성 : 사용자가 입력한 단어와 연관
- 정렬 : 인기도 등의 순위 모델에 의해 정렬
- 규모 확장성 : 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능
- 고가용성 : 시스템의 일부에 예상치 못한 문제가 생겨도 계속 사용 가능해야 함

### 개략적 규모 추정

- DAU는 천만 명으로 가정
- 한 사용자는 일평균 10건의 검색 수행
- 질의할 때마다 평균적으로 20바이트 데이터 입력
  - ASCII 인코딩 시 1문자 = 1바이트
  - 질의문은 평균 4개 단어, 각 단어는 평균 다섯 글자로 구성 가정
  - 결론적으로 질의 평균 20바이트
- 글자 입력 시 클라이언트가 백엔드에 자동완성 요청을 보냄
  - 평균적으로 1회 검색 당 20건의 요청이 백엔드로 전달
- 대략 초당 24,000건의 질의 발생
  - 10,000,000 사용자 x 10 질의 / 일 x 20자 / 24시간 / 3600초
- 최대 QPS = QPS x 2 = 대략 48,000
- 질의 가운데 20%는 신규 검색어라고 가정
  - 매일 0.4GB의 신규 데이터가 시스템에 추가

## 2단계 : 개략적 설계안 제시 및 동의 구하기

### 데이터 수집 서비스

- 사용자가 입력한 질의를 실시간으로 수집
- 질의문과 사용빈도를 저장하는 빈도 테이블로 데이터 수집 기록

### 질의 서비스

- 빈도 테이블을 기준으로 검색어의 "top 5" 자동완성 검색어를 표시
  - 빈도 테이블에 기록된 수치를 사용해 계산한다고 가정
  - SQL문으로 계산 가능 (`WHERE query Like 'prefix%' ORDER BY frequency DESC LIMIT 5`)
- 데이터가 아주 많아지면 데이터베이스 병목 발생 가능

## 3단계 : 상세 설계

- 다음 순서로 최적화 방안 논의
  - 트라이(trie) 자료구조, 데이터 수집 서비스, 질의 서비스

### 트라이 자료구조

- 트라이를 사용해 관계형 데이터베이스를 이용하던 효율적이지 못한 방법을 해결
- 트라이
  - 문자열을 간략하게 저장할 수 있는 자료구조
  - 트리 형태의 자료구조
  - 루트 노드는 빈 문자열
  - 각 노드마다 글자를 저장, 26개의 자식 노드
  - 각 트리 노드는 하나의 단어 or 접두어 문자열(prefix string)을 나타냄
  - 노드에 문자 및 빈도 정보까지 저장
- 알고리즘, 시간복잡도
  - p: 접두어의 길이
  - n: 트라이 안에 있는 노드 개수
  - c: 주어진 노드의 자식 노드 개수
  - 해당 접두어를 표현하는 노드를 찾음 (시간 복잡도 O(p))
  - 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾음 (시간 복잡도 O(c))
  - 유효 노드들을 정렬하여 가장 인기 있는 검색어 k개를 찾음 (시간 복잡도 O(clogc))
  - 이 알고리즘의 시간 복잡도는 각 단계에 소요된 시간의 합
- 최악의 경우엔 k개 결과를 얻으려고 전체 트라이를 다 검색할 수 있으므로 해결책 필요
  - 접두어의 최대 길이를 제한
  - 각 노드에 인기 검색어를 캐시
- 접두어 최대 길이 제한
  - p값을 작은 정수값이라고 가정
  - 검색어의 최대 길이를 제한할 수 있다면 "접두어 노드를 찾는" 단계의 시간 복잡도는 작은 상수값으로 바뀔 것
- 노드에 인기 검색어 캐시
  - 각 노드에 k개의 인기 검색어를 저장 (전체 트라이를 검색하는 것 방지)
  - 5~10 개 정도의 자동완성 제안을 표시하면 충분
  - 각 노드에 질의어를 저장할 공간이 많이 필요하게 된다는 단점

### 데이터 수집 서비스

- 사용자 타이핑 시 실시간 데이터 수정의 단점
  - 매일 입력되는 수천만 건의 질의마다 트라이를 갱신 시 질의 서비스가 심각하게 느려짐
  - 트라이가 만들어지면 인기 검색어는 자주 바뀌지 않을 것이므로 자주 갱신 필요 X
- 규모 확장이 쉬운 데이터 수집 서비스를 만들기 위해선 데이터가 어디서 오고 어떻게 이용되는지를 살펴야 함
- 데이터 분석 서비스 로그
  - 검색창에 입력된 질의에 관한 원본 데이터가 보관
  - 수정은 이루어지지 않음
  - 로그 데이터에 인덱스 X
- 로그 취합 서버
  - 데이터를 잘 취합하여 시스템이 쉽게 소비할 수 있도록 해야 함
  - 대부분의 경우 일주일에 한 번 정도로 로그를 취합해도 충분
- 취합된 데이터
  - time 필드는 해당 주가 시작한 날짜
  - frequency 필드는 해당 질의가 해당 주에 사용된 횟수의 합
  - 작업 서버 : 주기적으로 비동기적 작업을 실행하는 서버 집합, 트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할 담당
  - 트라이 캐시 : 분산 캐시 시스템, 데이터를 메모리에 유지하여 읽기 연산 성능을 높임, 매주 트라이 데이터베이스의 스냅샷을 떠 갱신
  - 트라이 데이터베이스 : 지속성 저장소, 문서 저장소 or 키-값 저장소

### 질의 서비스

- 검색 질의가 로드밸런서로 전송
- 로드밸런서는 해당 질의를 API 서버로 보냄
- API 서버는 트라이 캐시에서 데이터를 가져와 검색어 제안 응답 구성
- 캐시에 없을 시 DB에 가져와서 캐시에 채움
  - 캐시 미스는 캐시 서버의 메모리가 부족하거나 캐시 서버에 장애가 있어도 발생 가능
- 질의 서비스 최적화 방안
  - AJAX 요청 (페이지 새로고침 할 필요가 없는 것이 장점)
  - 브라우저 캐싱에 넣음 (ex. 구글 검색 엔진)
  - 데이터 샘플링 (N개 요청 가운데 1개만 로깅하도록 함)

### 트라이 연산

- 트라이 생성
  - 작업 서버가 담당
  - 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터를 이용
- 트라이 갱신
  - 매주 한 번 갱신하는 방법
  - 트라이의 각 노드를 개별적으로 갱신하는 방법 (성능이 좋지 않으므로 트라이가 작을 때는 고려해 봄직함)
- 검색어 삭제
  - 위험한 질의어를 자동완성 결과에서 제거해야 함
  - 트라이 캐시 앞에 필터 계층을 두고 부적절한 질의어가 반환되지 않도록 함

### 저장소 규모 확장

- 영어만 지원하면 되기 때문에 첫 글자를 기준으로 샤딩 가능
  - 데이터를 각 서버에 균등하게 배분하기는 불가능
- 과거 질의 데이터의 패턴을 분석하여 샤딩할 수 있음
  - 대응 샤드 관리자가 정보를 관리

## 4단계 : 마무리

- 다국어 지원이 가능하도록 어떻게 확장?
  - 트라이에 유니코드 데이터를 저장해야 함
- 국가별로 인기 검색어 순위가 다르다면?
  - 국가별로 다른 트라이
  - 트라이 CDN에 저장하여 응답속도를 높임
- 실시간으로 변하는 검색어의 추이를 반영하려면?
  - 샤딩을 통하여 작업 대상 데이터의 양을 줄임
  - 순위 모델을 바꾸어 최근 검색어에 보다 높은 가중치를 둠
  - 스트림 프로세싱
